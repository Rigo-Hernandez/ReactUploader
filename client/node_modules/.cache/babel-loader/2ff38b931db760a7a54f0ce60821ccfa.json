{"ast":null,"code":"'use strict';\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar Readable = require('stream').Readable; // Parameters for safe file name parsing.\n\n\nvar SAFE_FILE_NAME_REGEX = /[^\\w-]/g;\nvar MAX_EXTENSION_LENGTH = 3; // Parameters which used to generate unique temporary file names:\n\nvar TEMP_COUNTER_MAX = 65536;\nvar TEMP_PREFIX = 'tmp';\nvar tempCounter = 0;\n/**\r\n * Logs message to console if debug option set to true.\r\n * @param {Object} options - options object.\r\n * @param {String} msg     - message to log.\r\n * @returns {Boolean}\r\n */\n\nvar debugLog = function debugLog(options, msg) {\n  options = options || {};\n  if (!options.debug) return false;\n  console.log(msg); // eslint-disable-line\n\n  return true;\n};\n/**\r\n * Generates unique temporary file name like: tmp-5000-156788789789.\r\n * @param prefix {String} - a prefix for generated unique file name.\r\n * @returns {String}\r\n */\n\n\nvar getTempFilename = function getTempFilename(prefix) {\n  prefix = prefix || TEMP_PREFIX;\n  tempCounter++;\n  if (tempCounter > TEMP_COUNTER_MAX) tempCounter = 1;\n  return \"\".concat(prefix, \"-\").concat(tempCounter, \"-\").concat(Date.now());\n};\n/**\r\n * Returns true if argument is a function.\r\n * @returns {Boolean}\r\n */\n\n\nvar isFunc = function isFunc(func) {\n  return func && func.constructor && func.call && func.apply ? true : false;\n};\n/**\r\n * Set errorFunc to the same value as successFunc for callback mode.\r\n * @returns {Function}\r\n */\n\n\nvar errorFunc = function errorFunc(resolve, reject) {\n  return isFunc(reject) ? reject : resolve;\n};\n/**\r\n * Return a callback function for promise resole/reject args.\r\n * @returns {Function}\r\n */\n\n\nvar promiseCallback = function promiseCallback(resolve, reject) {\n  return function (err) {\n    if (err) {\n      errorFunc(resolve, reject)(err);\n    } else {\n      resolve();\n    }\n  };\n};\n/**\r\n * Builds instance options from arguments objects.\r\n * @returns {Object} - result options.\r\n */\n\n\nvar buildOptions = function buildOptions() {\n  var result = {};\n  Array.prototype.slice.call(arguments).forEach(function (options) {\n    if (!options || typeof options !== 'object') return;\n    Object.keys(options).forEach(function (key) {\n      return result[key] = options[key];\n    });\n  });\n  return result;\n};\n/**\r\n * Builds request fields (using to build req.body and req.files)\r\n * @param {Object} instance - request object.\r\n * @param {String} field    - field name.\r\n * @param value             - field value.\r\n * @returns {Object}\r\n */\n\n\nvar buildFields = function buildFields(instance, field, value) {\n  //Do nothing if value is not set.\n  if (value === null || value === undefined) {\n    return instance;\n  }\n\n  instance = instance || {}; // Non-array fields\n\n  if (!instance[field]) {\n    instance[field] = value;\n  } else {\n    // Array fields  \n    if (instance[field] instanceof Array) {\n      instance[field].push(value);\n    } else {\n      instance[field] = [instance[field], value];\n    }\n  }\n\n  return instance;\n};\n/**\r\n * Creates a folder for file specified in the path variable\r\n * @param {Object} fileUploadOptions\r\n * @param {String} filePath\r\n */\n\n\nvar checkAndMakeDir = function checkAndMakeDir(fileUploadOptions, filePath) {\n  //Check upload options were set.\n  if (!fileUploadOptions) return false;\n  if (!fileUploadOptions.createParentPath) return false; //Check whether folder for the file exists.\n\n  if (!filePath) return false;\n  var parentPath = path.dirname(filePath); //Create folder if it is not exists.\n\n  if (!fs.existsSync(parentPath)) fs.mkdirSync(parentPath);\n  return true;\n};\n/**\r\n * Delete file.\r\n * @param {String} file - Path to the file to delete.\r\n */\n\n\nvar deleteFile = function deleteFile(file, callback) {\n  fs.unlink(file, function (err) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    callback();\n  });\n};\n/**\r\n * Copy file via streams\r\n * @param {String} src - Path to the source file\r\n * @param {String} dst - Path to the destination file.\r\n */\n\n\nvar copyFile = function copyFile(src, dst, callback) {\n  //cbCalled flag and runCb helps to run cb only once.\n  var cbCalled = false;\n\n  var runCb = function runCb(err) {\n    if (cbCalled) return;\n    cbCalled = true;\n    callback(err);\n  }; //Create read stream\n\n\n  var readable = fs.createReadStream(src);\n  readable.on('error', runCb); //Create write stream\n\n  var writable = fs.createWriteStream(dst);\n  writable.on('error', function (err) {\n    readable.destroy();\n    runCb(err);\n  });\n  writable.on('close', function () {\n    return runCb();\n  }); //Copy file via piping streams.\n\n  readable.pipe(writable);\n};\n/**\r\n * Move file via streams by copieng and the deleteing src.\r\n * @param {String}   src      - Path to the source file\r\n * @param {String}   dst      - Path to the destination file.\r\n * @param {Function} callback - A callback function.\r\n */\n\n\nvar moveFile = function moveFile(src, dst, callback) {\n  // Copy file to dst.\n  copyFile(src, dst, function (err) {\n    if (err) {\n      callback(err);\n      return;\n    } // Delete src file.\n\n\n    deleteFile(src, callback);\n  });\n};\n/**\r\n * Save buffer data to a file.\r\n * @param {Buffer} buffer - buffer to save to a file.\r\n * @param {String} filePath - path to a file.\r\n */\n\n\nvar saveBufferToFile = function saveBufferToFile(buffer, filePath, callback) {\n  if (!Buffer.isBuffer(buffer)) {\n    callback(new Error('buffer variable should be a Buffer!'));\n    return;\n  } //Setup readable stream from buffer.\n\n\n  var streamData = buffer;\n  var readStream = Readable();\n\n  readStream._read = function () {\n    readStream.push(streamData);\n    streamData = null;\n  }; //Setup file system writable stream.\n\n\n  var fstream = fs.createWriteStream(filePath);\n  fstream.on('error', function (error) {\n    return callback(error);\n  });\n  fstream.on('close', function () {\n    return callback();\n  }); //Copy file via piping streams.\n\n  readStream.pipe(fstream);\n};\n/**\r\n * Parses filename and extension and returns object {name, extension}.\r\n * @param preserveExtension {Boolean, Integer} - true/false or number of characters for extension.\r\n * @param fileName {String}                    - file name to parse.\r\n * @returns {Object}                           - {name, extension}.\r\n */\n\n\nvar parseFileNameExtension = function parseFileNameExtension(preserveExtension, fileName) {\n  var preserveExtensionLengh = parseInt(preserveExtension);\n  var result = {\n    name: fileName,\n    extension: ''\n  };\n\n  if (!preserveExtension && preserveExtensionLengh !== 0) {\n    return result;\n  } // Define maximum extension length\n\n\n  var maxExtLength = isNaN(preserveExtensionLengh) ? MAX_EXTENSION_LENGTH : Math.abs(preserveExtensionLengh);\n  var nameParts = fileName.split('.');\n\n  if (nameParts.length < 2) {\n    return result;\n  }\n\n  var extension = nameParts.pop();\n\n  if (extension.length > maxExtLength && maxExtLength > 0) {\n    nameParts[nameParts.length - 1] += '.' + extension.substr(0, extension.length - maxExtLength);\n    extension = extension.substr(-maxExtLength);\n  }\n\n  result.extension = maxExtLength ? extension : '';\n  result.name = nameParts.join('.');\n  return result;\n};\n/**\r\n * Parse file name and extension.\r\n * @param opts {Object}     - middleware options.\r\n * @param fileName {String} - Uploaded file name.\r\n * @returns {String}\r\n */\n\n\nvar parseFileName = function parseFileName(opts, fileName) {\n  if (!opts.safeFileNames) {\n    return fileName;\n  } // Set regular expression for the file name.\n\n\n  var safeNameRegex = typeof opts.safeFileNames === 'object' && opts.safeFileNames instanceof RegExp ? opts.safeFileNames : SAFE_FILE_NAME_REGEX; // Parse file name extension.\n\n  var _parseFileNameExtensi = parseFileNameExtension(opts.preserveExtension, fileName),\n      name = _parseFileNameExtensi.name,\n      extension = _parseFileNameExtensi.extension;\n\n  if (extension.length) extension = '.' + extension.replace(safeNameRegex, '');\n  return name.replace(safeNameRegex, '').concat(extension);\n};\n\nmodule.exports = {\n  debugLog: debugLog,\n  isFunc: isFunc,\n  errorFunc: errorFunc,\n  promiseCallback: promiseCallback,\n  buildOptions: buildOptions,\n  buildFields: buildFields,\n  checkAndMakeDir: checkAndMakeDir,\n  deleteFile: deleteFile,\n  // For testing purpose.\n  copyFile: copyFile,\n  // For testing purpose.\n  moveFile: moveFile,\n  saveBufferToFile: saveBufferToFile,\n  parseFileName: parseFileName,\n  getTempFilename: getTempFilename\n};","map":null,"metadata":{},"sourceType":"script"}